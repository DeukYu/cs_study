# 가상 메모리
- 프로세스의 일부만 메모리에 로드하고, 나머지는 디스크에 둔 상태로 프로세스를 실행하는 방식
- 물리적 메모리(RAM)가 제한적인 경우에도 더 큰 프로그램을 실행할 수 있게 됩니다.

--- 

## 가상 메모리의 동작 방식
1. **필요한 부분만 메모리에 로드 (Demand Paging)**
    - 프로세스의 전체 데이터를 물리적 메모리에 한 번에 모두 올리지 않고, 필요한 부분만 물리 메모리에 로드합니다.
    - 실행 중인 코드나 데이터 중 실제로 참조되는 부분만 메모리에 올리고, 나머지는 디스크에 저장된 상태로 유지됩니다.
    - 이 디스크 영역을 스왑 영역(Swap Space) 또는 **페이지 파일(Page File)** 이라고 합니다.

2. **나중에 필요한 데이터는 디스크에서 가져옴**
    - 프로세스가 아직 메모리에 로드되지 않은 데이터나 코드를 요청하면, **페이지 폴트(Page Fault)** 가 발생합니다.
    - 운영 체제는 요청된 데이터를 디스크에서 읽어와 메모리에 로드한 뒤, 프로세스가 이를 사용할 수 있도록 합니다.
    - 반대로, 물리 메모리가 부족할 경우 사용하지 않는 페이지를 디스크로 내보내는 스왑(Swapping) 작업이 수행됩니다.

3. **페이징(Paging)**
    - 가상 메모리 공간은 고정 크기의 페이지로 나뉘며, 물리 메모리 역시 같은 크기의 **페이지 프레임(Page Frame)** 으로 나뉩니다.
    - 가상 주소와 물리 주소는 페이지 단위로 매핑되며, 이 매핑 정보를 관리하는 자료 구조를 **페이지 테이블(Page Table)** 이라고 합니다.

---

## 가상 메모리 장점
- **물리 메모리보다 큰 프로그램 실행 가능**
    - 물리 메모리(RAM)가 4GB라고 해도, 프로세스가 사용하는 가상 메모리는 8GB 이상일 수 있습니다. 실제로 참조되는 페이지만 메모리에 올라가고, 나머지는 디스크에 저장되기 때문입니다.

- **효율적인 메모리 활용**
    - 대부분의 프로그램은 실행 중에 전체 메모리를 사용하지 않습니다. 자주 사용하지 않는 페이지를 디스크에 저장해두면, 물리 메모리를 더 효율적으로 활용할 수 있습니다.

- **프로세스 간 메모리 보호**
    - 각 프로세스는 독립적인 가상 메모리 공간을 가지므로, 하나의 프로세스가 다른 프로세스의 메모리에 접근할 수 없습니다.

## 가상 메모리 단점
- **속도 저하(I/O 병목)
    - 디스크는 RAM보다 훨씬 느리기 때문에, **페이지 폴트** 가 자주 발생하면 성능이 크게 저하됩니다. 이를 **스레싱(Thrashing)** 이라고 합니다.
- **추가적인 관리 비용**
    - 페이지 테이블 관리, 디스크 I/O 작업 등으로 인해 운영 체제의 오버헤드가 증가합니다.

---

## 요구 페이징 (Demand Paging)
![image](https://github.com/user-attachments/assets/3c2fa755-84c7-4618-9478-e6ad52d8756e)
- 프로세스에서 필요한 페이지만 메모리에 로드하는 방식
- 그림과 같이 필요한 페이지를 물리 메모리에 로드하고, 필요하지 않은 페이지는 디스크에 저장
- 물리 메모리에 필요한 페이지가 없을 때 이를 **페이지 폴트(page fault)** 라고 한다.
- 페이지 폴트가 발생하면 디스크에서 필요한 페이지를 스왑인한다.
- 이때 페이지에 해당하는 메모리 영역이 물리 메모리에 있는지는 페이지 테이블로 파악할 수 있다.
- 페이지 테이블은 페이지에 해당하는 프레임이 존재하면 `v(valid)` 값을, 프레임이 존재하지 않거나 유효하지 않은 주소 값이면 `i(invalid)` 값을 반환한다.

---

## 페이지 폴트 발생 시 처리 과정
![image](https://github.com/user-attachments/assets/4afc7e6e-c370-4ff9-8846-214357647404)
1. 필요한 페이지가 물리 메모리에 있는지 없는지를 **페이지 테이블** 에서 확인한다. 페이지 폴트가 발생하면 `i`를 반환한다.
2. `i`를 반환하면 OS는 참조하려는 페이지의 주소 값이 유효하지 않은지 아니면 메모리에 로드되지 않은 영역인지 파악한다.
3. 필요한 페이지가 메모리에 로드되지 않은 영역이라면 디스크에서 해당 영역을 찾는다.
4. 디스크에서 해당 페이지 영역을 **스왑 인** 한다. 이때 물리 메모리에 비어 있는 프레임(free frame)이 있으면 페이지를 해당 영역에 바로 로드한다. 만약 비어 있는 프레임이 없으면 **페이지 교체 알고리즘** 을 호출해 기존에 로드된 페이지를 디스크로 **스왑 아웃** 한 후 새로운 페이지를 로드한다.
5. 페이지 테이블에서 새로 로드한 값을 v로 변경한다.
6. 프로세스를 다시 실행한다.