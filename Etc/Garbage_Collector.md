# Garbage Collector(GC)
- 런타임중에 사용되지 않는 메모리를 해제하여 관리
- 일정 시점마다 사용되고 있는 객체, 더 이상 사용되지 않는 객체를 판단하여 해제

## 1. 마크 앤 스윕(Mark and Sweep)
- 객체가 사용 중인지 여부를 판단하고 사용되지 않는 객체는 해제하여 메모리를 반환
- 주로 세대별 GC와 같이 사용됨
  
### 작동 원리
- **마크 단계**
   - 애플리케이션의 루트 객체(스택, 전역 변수 등) 에서 시작하여 
		'도달 가능한 객체',
		'사용자가 참조 가능한 객체'
		를 탐색하여 마킹
   - 객체 간 참조 관계를 따라가며 연결된 모든 객체를 확인
   - 참조되지 않은 객체는 마킹 되지 않음
- **스윕 단계**
   - 메모리 (힙)를 순회하여 마킹되지 않은 객체를 메모리 해제
 
### 주요 특징
- **장점**
  - 구현이 단순
  - 대부분의 가비지 컬렉션 기초가 되는 알고리즘
- **단점**
  - 런타임 정지 (Stop the world): 가비지 컬렉션 동안 애플리케이션 실행이 중지
  - 메모리 단편화: 객체가 해제된 후 메모리 공간이 연속적으로 되어있지 않음
  - 느린 실행 속도: 힙 메모리를 전체적으로 탐색하여 느림

### 개선
 - **마크 앤 스윕 컴팩트 (Mark and Sweep Compact)**
   - 메모리 단편화 방지를 위해 메모리들을 연속적으로 몰아준다
   - 추가적인 오버헤드 발생
   
## 2. 참조 카운팅 (Reference Counting)
- 객체가 참조되는 횟수를 기록하여 사용되지 않는 객체를 자동으로 제거

### 작동 원리
- **참조 카운트 초기화**
  - 객체가 생성되면 참조 카운트가 1로 설정
- **참조 증가**
  - 객체에 새로운 참조가 생길 때 (복사, 속성으로 추가 등)
- **참조 감소**
  - 객체를 참조하는 변수가 삭제되거나 다른 값을 참조할 때
- **객체 삭제**
  - 참조 카운트가 0이 되면 삭제
    
### 주요 특징
 - **장점**
   - 즉시 메모리 해제
   - 구현이 간단
   - 해제 시점 예측 가능
 - **단점**
   - 순환 참조 문제
   - 참조 관리로 인한 오버헤드
   - 멀티스레드에 안전하지 않음

## 3. 복사형 GC (Copying GC)
- 단편화 문제를 해결하기 위해 제시

### 작동 원리
 - **메모리 분할**
   - 메모리를 실행중인 객체 공간, 활성 객체를 복사하여 보관하는 공간 동일한 두 개의 공간으로 분리
 - **가비지 컬렉션 트리거**
   - 실행중인 객체 공간이 가득 차면 실행
 - **활성 객체 복사**
   - 참조가 있는 객체를 탐색
   - 다른 공간으로 복사 후 새로운 메모리 주소 할당
 - **메모리 정리 및 스왑**
   - 복사가 완료되면 역할이 전환되며 이전 공간은 정리
  
### 주요 특징
 - **장점**
   - 빠른 메모리 할당
   - 복사하여 저장하므로 메모리 단편화 방지
   - 대부분의 객체는 첫 번째 GC에 소멸되므로 효율적인 짧은 생명 주기를 갖고있음
   - 사용되는 객체만 복사하는 간단한 구현
 - **단점**
   - 메모리를 두 영역으로 나누기에 메모리를 절반만 사용
   - 실행될 때마다 복사가 일어나므로 비용이 소모됨
   - 긴 생명주기를 갖고 있는 객체는 매 GC마다 복사가 되므로 비효율 (세대별 GC로 보완 가능)
## 4. 세대별 GC (Generational GC)
- 메모리를 세대로 나누어 관리
- 0, 1, 2 세대 또는 젊은, 오래된 세대 로 나눈다.
- **젊은 세대(Young generation)**
  - 새로 저장된 객체가 저장되는 영역
  - 객체의 생명 주기가 짧다는 가정에 따라 자주 GC가 실행됨
  - 더 상세하게 처음 생성된 객체(Eden), 한 번 이상 살아남은 객체의 공간(Survivor)으로 분리됨
    
- **오래된 세대(Old generation)**
  - 젊은 세대에서 오래 생존한 객체가 이동됨
  - 오래 생존했기에 소멸 가능성이 낮아 GC가 드물게 실행됨

-  **영구 세대**
  - 메타 데이터, 클래스 정의 등과 같은 정적인 데이터를 저장하는 영역
  - 소멸 가능성이 거의 없다

### 작동 원리
 - **객체 생성**
   - 객체는 처음에 젊은 영역의 Eden에 생성
 - **젊은 세대 GC**
   - Eden이 가득 차면 GC가 실행되여 사용중인 객체를 Survivor로 복사
   - Eden은 초기화 되고 새로운 객체를 할당
   - Survivor에서 지속해서 살아남으면 오래된 세대로 이동
 - **오래된 세대 GC**
   - 젊은 세대보다 드물게 GC가 실행됨
   - 주로 마크 앤 스윕, 마크 앤 스윕 컴팩트를 사용

### 주요 특징
 - **장점**
   - 짧은 생명주기를 위한 공간과 긴 생명주기를 위한 공간이 나누어져 있어 GC성능이 최적화
   - 오래된 생명 주기로 복사되며 단편화가 방지됨
   - 젊은 세대에서 빠르게 GC가 실행되므로 오버헤드가 적다.
     
 - **단점**
   - 세대가 나누어져 있어 참조를 관리하는데 추가적인 관리 비용이 존재
   - 오래된 세대의 GC는 실행시 오래걸릴수 있음
